<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ajedrez con Stockfish</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f4f4f4;
      text-align: center;
      margin: 0;
      padding: 20px;
    }

    .descripcion {
      max-width: 700px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      text-align: left;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      width: 480px;
      margin: 0 auto;
      border: 2px solid #333;
    }

    .square {
      width: 60px;
      height: 60px;
      line-height: 60px;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
    }

    .white {
      background-color: #eee;
    }

    .black {
      background-color: #888;
      color: white;
    }

    #status {
      margin-top: 15px;
      font-size: 18px;
    }

    .controls button {
      margin: 10px 5px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>

  <div class="descripcion">
    <p>Existen redes neuronales y motores de ajedrez ya entrenados que están disponibles en línea. Estos motores han sido desarrollados y afinados durante años, y pueden ser reutilizados en nuestros propios proyectos gracias a que muchos son de código abierto y están accesibles desde la web.</p>
    <p>En este caso, utilizamos un motor de ajedrez ya entrenado llamado <strong>Stockfish</strong>, uno de los más potentes del mundo. Optamos por usar un motor ya entrenado porque crear y entrenar una red neuronal que comprenda bien el ajedrez requeriría una enorme cantidad de tiempo, datos y poder computacional.</p>
    <p>El motor que usamos ha sido entrenado utilizando más de 10.000 partidas de ajedrez reales, jugadas por expertos y grandes maestros. Gracias a eso, el modelo ha aprendido a evaluar millones de posiciones distintas y a predecir cuál es la mejor jugada en una situación dada.</p>
  </div>

  <div class="controls">
    <button onclick="startGame('w')">Jugar como Blancas</button>
    <button onclick="startGame('b')">Jugar como Negras</button>
    <button onclick="resetGame()">Reiniciar</button>
  </div>

  <div id="board"></div>
  <div id="status">Selecciona un color para comenzar</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stockfish@15.1.0/stockfish.min.js"></script>
  <script>
    const boardElement = document.getElementById("board");
    const statusElement = document.getElementById("status");
    const pieceUnicode = {
      'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
      'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
    };

    let game = new Chess();
    let engine = Stockfish();
    let selected = null;
    let playingAs = 'w';

    function drawBoard() {
      boardElement.innerHTML = '';
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const square = document.createElement("div");
          const isWhite = (i + j) % 2 === 0;
          square.className = `square ${isWhite ? 'white' : 'black'}`;
          square.dataset.row = i;
          square.dataset.col = j;
          const piece = board[i][j];
          if (piece) square.textContent = pieceUnicode[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
          square.onclick = () => handleClick(i, j);
          boardElement.appendChild(square);
        }
      }
    }

    function handleClick(row, col) {
      const square = String.fromCharCode(97 + col) + (8 - row);
      const piece = game.get(square);
      if (selected) {
        const move = game.move({ from: selected, to: square, promotion: 'q' });
        selected = null;
        if (move) {
          drawBoard();
          updateStatus();
          if (game.turn() !== playingAs && !game.game_over()) {
            setTimeout(makeEngineMove, 200);
          }
        }
      } else if (piece && piece.color === playingAs) {
        selected = square;
      }
    }

    function makeEngineMove() {
      engine.postMessage("position fen " + game.fen());
      engine.postMessage("go depth 15");
    }

    engine.onmessage = function(event) {
      const line = typeof event === "object" ? event.data : event;
      if (line.startsWith("bestmove")) {
        const move = line.split(" ")[1];
        game.move({ from: move.substring(0, 2), to: move.substring(2, 4), promotion: 'q' });
        drawBoard();
        updateStatus();
      }
    };

    function updateStatus() {
      if (game.in_checkmate()) {
        statusElement.textContent = '¡Jaque mate!';
      } else if (game.in_draw()) {
        statusElement.textContent = '¡Empate!';
      } else {
        statusElement.textContent = game.turn() === playingAs ? 'Tu turno (' + (playingAs === 'w' ? 'Blancas' : 'Negras') + ')' : 'Pensando...';
      }
    }

    function startGame(color) {
      playingAs = color;
      game.reset();
      drawBoard();
      updateStatus();
      if (playingAs === 'b') makeEngineMove();
    }

    function resetGame() {
      selected = null;
      game.reset();
      drawBoard();
      statusElement.textContent = 'Selecciona un color para comenzar';
    }
  </script>
</body>
</html>
