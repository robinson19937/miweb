<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Red Neuronal Trigonométrica</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100">

  <!-- Contenido -->
  <div class="max-w-2xl mx-auto px-4 py-2">
    <h1 class="text-lg md:text-2xl font-bold mb-2 leading-tight">
      Red Neuronal para el Cálculo de Funciones Trigonométricas
    </h1>
    <p class="text-sm md:text-base mb-2 leading-snug">
      En este proyecto usamos redes neuronales para que la web aprenda a calcular valores trigonométricos. No usamos una calculadora tradicional, sino un modelo que aprende de datos. Por eso puede haber pequeñas diferencias mientras se entrena. Por ejemplo, el seno de 90 es 1, pero el modelo podría predecir algo como 0.95.
    </p>
    <p class="text-sm md:text-base font-bold">
      Desarrollado por: Robinson López
    </p>
  </div>

  <!-- Contenedor del canvas -->
  <div id="canvas-container" class="flex justify-center mt-4 md:mt-6"></div>

  <script>
let model;
let angleInput = 0;
let prediction = [0, 0, 0];
let trainingData = [];
let isTrained = false;
let previousTouchX = 0;
let canvas;
let loadingModel = true;

async function setup() {
  let canvasSize = min(windowWidth * 0.95, windowHeight * 0.5);
  canvas = createCanvas(canvasSize, canvasSize);
  canvas.parent('canvas-container');

  try {
    if (localStorage.getItem('mi-modelo')) {
      model = await tf.loadLayersModel('localstorage://mi-modelo');
      isTrained = true;
      loadingModel = false;
    } else {
      await trainModel();
    }
  } catch (error) {
    console.error("Error al cargar o entrenar el modelo:", error);
    isTrained = false;
    loadingModel = false;
  }

  window.addEventListener('keydown', handleKeyPress);
}

async function trainModel() {
  loadingModel = true;
  model = tf.sequential();
  model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [1] }));
  model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
  model.add(tf.layers.dense({ units: 3 }));
  model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

  trainingData = [];
  for (let i = 0; i < 1000; i++) {
    let deg = random(0, 360);
    let rad = deg * PI / 180;
    trainingData.push({
      input: deg / 360,
      output: [sin(rad), cos(rad), rad]
    });
  }

  const xs = tf.tensor2d(trainingData.map(d => [d.input]));
  const ys = tf.tensor2d(trainingData.map(d => d.output));

  try {
    await model.fit(xs, ys, {
      epochs: 100,
      shuffle: true,
      callbacks: {
        onEpochEnd: (epoch, logs) => {
          console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
        }
      }
    });
    isTrained = true;
    loadingModel = false;
    await model.save('localstorage://mi-modelo');
  } catch (error) {
    console.error("Error durante el entrenamiento:", error);
    loadingModel = false;
  }

  xs.dispose();
  ys.dispose();
}

function draw() {
  background(255);
  let textScale = width / 400;
  textSize(14 * textScale);
  textAlign(LEFT);
  fill(0);

  if (loadingModel) {
    push();
    textSize(24 * textScale);
    fill(255, 0, 0);
    textStyle(BOLD);
    textAlign(CENTER, CENTER);
    text("⚠️ Entrenando red neuronal...\nEsto puede tardar 1-2 minutos", width / 2, height / 2);
    textStyle(NORMAL);
    pop();
    return;
  }

  text(`Ángulo (grados): ${angleInput.toFixed(2)}`, 10 * textScale, 20 * textScale);
  text('Desliza o usa flechas para cambiar ángulo', 10 * textScale, 40 * textScale);

  if (isTrained && model) {
    try {
      let inputTensor = tf.tensor2d([[angleInput / 360]]);
      let outputTensor = model.predict(inputTensor);
      prediction = outputTensor.dataSync();
      inputTensor.dispose();
      outputTensor.dispose();

      text(`Seno: ${prediction[0].toFixed(4)}`, 10 * textScale, height - 60 * textScale);
      text(`Coseno: ${prediction[1].toFixed(4)}`, 10 * textScale, height - 40 * textScale);
      text(`Radianes: ${prediction[2].toFixed(4)}`, 10 * textScale, height - 20 * textScale);

      translate(width / 2, height / 2);
      scale(1, -1);

      stroke(0);
      line(-width * 0.25, 0, width * 0.25, 0);
      line(0, -height * 0.25, 0, height * 0.25);

      noFill();
      ellipse(0, 0, width * 0.5, width * 0.5);

      let rad = angleInput * PI / 180;
      let x = cos(rad) * (width * 0.25);
      let y = sin(rad) * (width * 0.25);
      fill(255, 0, 0);
      ellipse(x, y, 10 * textScale, 10 * textScale);

      stroke(255, 0, 0);
      line(0, 0, x, y);
    } catch (error) {
      console.error("Error en la predicción:", error);
    }
  }
}

function handleKeyPress(event) {
  if (event.key === 'ArrowLeft') {
    angleInput -= 0.5;
  } else if (event.key === 'ArrowRight') {
    angleInput += 0.5;
  }
  angleInput = constrain(angleInput, 0, 360);
}

function touchMoved() {
  let deltaX = mouseX - previousTouchX;
  angleInput += deltaX * 0.1;
  angleInput = constrain(angleInput, 0, 360);
  previousTouchX = mouseX;
  return false;
}

function windowResized() {
  let canvasSize = min(windowWidth * 0.95, windowHeight * 0.5);
  resizeCanvas(canvasSize, canvasSize);
}
  </script>
</body>
</html>

