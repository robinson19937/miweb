<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div class="max-w-2xl mx-auto p-4 text-gray-800">
    <h1 class="text-xl md:text-2xl font-bold mb-4">Red Neuronal para el C√°lculo de Funciones Trigonom√©tricas</h1>
    <p class="text-base md:text-lg mb-4">
      En este proyecto usamos redes neuronales para entrenar la web de tal forma que pueda calcular o predecir valores trigonom√©tricos. Esto es un avance realmente significativo en el √°mbito de la programaci√≥n, ya que no estamos usando una calculadora; solo estamos usando datos para que la fuente se alimente de esos datos y pueda aprender a hacer c√°lculos trigonom√©tricos. En pocas palabras, es como si le estuvi√©ramos ense√±ando a hacer estos c√°lculos de igual forma a como un ser humano lo har√≠a. Por eso se llaman redes neuronales, mientras la red se entrena es posible que exista una peque√±a varianza ya que mientras se entrena podria sacar resultados no muy precisos pero si muy aproximados ejemplo , el seno de 90 es 1 podria sacar una aproximacion como 0.95
    </p>
    <p class="text-base md:text-lg font-bold">
      Desarrollado por: Robinson L√≥pez
    </p>
  </div>

  <!-- Bot√≥n para reiniciar modelo -->
  <div class="max-w-2xl mx-auto text-center my-4">
    <button id="resetBtn" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition">
      üîÑ Reiniciar Modelo
    </button>
  </div>

  <!-- Contenedor para el canvas -->
  <div id="canvas-container" class="flex justify-center mt-8"></div>

  <script>
let model;
let angleInput = 0;
let prediction = [0, 0, 0]; // [sin, cos, radianes]
let trainingData = [];
let isTrained = false;
let previousTouchX = 0;
let canvas;
let loadingModel = true;

async function setup() {
  let canvasSize = min(windowWidth * 0.8, windowHeight * 0.6);
  canvas = createCanvas(canvasSize, canvasSize);
  canvas.parent('canvas-container');

  console.log("Iniciando setup...");

  try {
    if (localStorage.getItem('mi-modelo')) {
      console.log("Cargando modelo desde localStorage...");
      model = await tf.loadLayersModel('localstorage://mi-modelo');
      console.log("Modelo cargado exitosamente.");
      isTrained = true;
      loadingModel = false;
    } else {
      console.log("No hay modelo en localStorage. Entrenando uno nuevo...");
      await trainModel();
    }
  } catch (error) {
    console.error("Error al cargar o entrenar el modelo:", error);
    isTrained = false;
    loadingModel = false;
  }

  window.addEventListener('keydown', handleKeyPress);
}

async function trainModel() {
  loadingModel = true;
  model = tf.sequential();
  model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [1] }));
  model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
  model.add(tf.layers.dense({ units: 3 }));
  model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

  trainingData = [];
  for (let i = 0; i < 1000; i++) {
    let deg = random(0, 360);
    let rad = deg * PI / 180;
    trainingData.push({
      input: deg / 360,
      output: [sin(rad), cos(rad), rad]
    });
  }

  const xs = tf.tensor2d(trainingData.map(d => [d.input]));
  const ys = tf.tensor2d(trainingData.map(d => d.output));

  console.log("Entrenando modelo...");
  try {
    await model.fit(xs, ys, {
      epochs: 100,
      shuffle: true,
      callbacks: {
        onEpochEnd: (epoch, logs) => {
          console.log(`Epoch ${epoch}: loss = ${logs.loss}`);
        }
      }
    });
    console.log("Entrenamiento completado.");
    isTrained = true;
    loadingModel = false;
    await model.save('localstorage://mi-modelo');
    console.log("Modelo guardado en localStorage.");
  } catch (error) {
    console.error("Error durante el entrenamiento:", error);
    loadingModel = false;
  }

  xs.dispose();
  ys.dispose();
}

function draw() {
  background(255);
  let textScale = width / 400;
  textSize(16 * textScale);
  textAlign(LEFT);
  fill(0);

  if (loadingModel) {
    push();
    textAlign(CENTER, CENTER);
    textSize(24 * textScale);
    fill(50);
    text("‚è≥ Cargando o entrenando modelo puede tardar de 1 a 2 minutos mientras se entrena la red neuronal ", width / 2, height / 2);
    pop();
    return;
  }

  text(`√Ångulo (grados): ${angleInput.toFixed(2)}`, 10 * textScale, 20 * textScale);
  text('Usa las flechas o desliza para cambiar el √°ngulo', 10 * textScale, 40 * textScale);

  if (isTrained && model) {
    try {
      let inputTensor = tf.tensor2d([[angleInput / 360]]);
      let outputTensor = model.predict(inputTensor);
      prediction = outputTensor.dataSync();
      inputTensor.dispose();
      outputTensor.dispose();

      text(`Seno: ${prediction[0].toFixed(4)}`, 10 * textScale, height - 60 * textScale);
      text(`Coseno: ${prediction[1].toFixed(4)}`, 10 * textScale, height - 40 * textScale);
      text(`Radianes: ${prediction[2].toFixed(4)}`, 10 * textScale, height - 20 * textScale);

      translate(width / 2, height / 2);
      scale(1, -1);

      stroke(0);
      line(-width * 0.25, 0, width * 0.25, 0);
      line(0, -height * 0.25, 0, height * 0.25);

      noFill();
      ellipse(0, 0, width * 0.5, width * 0.5);

      let rad = angleInput * PI / 180;
      let x = cos(rad) * (width * 0.25);
      let y = sin(rad) * (width * 0.25);
      fill(255, 0, 0);
      ellipse(x, y, 10 * textScale, 10 * textScale);

      stroke(255, 0, 0);
      line(0, 0, x, y);
    } catch (error) {
      console.error("Error en la predicci√≥n:", error);
    }
  }
}

function handleKeyPress(event) {
  if (event.key === 'ArrowLeft') {
    angleInput -= 0.5;
  } else if (event.key === 'ArrowRight') {
    angleInput += 0.5;
  }
  angleInput = constrain(angleInput, 0, 360);
}

function touchMoved() {
  let deltaX = mouseX - previousTouchX;
  angleInput += deltaX * 0.1;
  angleInput = constrain(angleInput, 0, 360);
  previousTouchX = mouseX;
  return false;
}

function windowResized() {
  let canvasSize = min(windowWidth * 0.8, windowHeight * 0.6);
  resizeCanvas(canvasSize, canvasSize);
}

// Funci√≥n para reiniciar modelo
document.getElementById('resetBtn').addEventListener('click', async () => {
  if (confirm('¬øEst√°s seguro de que deseas reiniciar el modelo? Esto eliminar√° el modelo actual.')) {
    localStorage.removeItem('tensorflowjs_models/mi-modelo/info');
    localStorage.removeItem('tensorflowjs_models/mi-modelo/model_topology');
    localStorage.removeItem('tensorflowjs_models/mi-modelo/weight_data');
    localStorage.removeItem('tensorflowjs_models/mi-modelo/weight_specs');

    isTrained = false;
    trainingData = [];
    prediction = [0, 0, 0];
    loadingModel = true;
    console.log("Modelo eliminado. Iniciando nuevo entrenamiento...");
    await trainModel();
  }
});
  </script>
</body>
</html>
